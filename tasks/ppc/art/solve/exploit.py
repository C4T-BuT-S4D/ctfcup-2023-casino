import sys
from itertools import product

from pwn import *
from rubik import cube
from rubik.cube import Cube
from rubik.maths import Point
from tqdm import tqdm

W, H = 97, 5
COLORS = set("WYROGB")


class Painter:
    def __init__(self, c):
        self.cube = c
        self.colors = c.colors()
        self.moves = []

        self.left_piece = self.cube.find_piece(self.cube.left_color())
        self.right_piece = self.cube.find_piece(self.cube.right_color())
        self.up_piece = self.cube.find_piece(self.cube.up_color())
        self.down_piece = self.cube.find_piece(self.cube.down_color())

        self.inifinite_loop_max_iterations = 12

    def paint(self, face):
        self.orient(face[4])

        self.left_piece = self.cube.find_piece(self.cube.left_color())
        self.right_piece = self.cube.find_piece(self.cube.right_color())
        self.up_piece = self.cube.find_piece(self.cube.up_color())
        self.down_piece = self.cube.find_piece(self.cube.down_color())
        self.front_piece = self.cube.find_piece(self.cube.front_color())

        self.place_edges(face[3], face[5], face[1], face[7])
        self.place_corners(face[8], face[2], face[0], face[6])

    def orient(self, face_color):
        if self.cube.front_color() == face_color:
            return

        move_str = {
            self.cube.left_color(): "Yi",
            self.cube.right_color(): "Y",
            self.cube.up_color(): "Xi",
            self.cube.down_color(): "X",
            self.cube.back_color(): "X X",
        }

        self.move(move_str[face_color])

    def place_edges(self, *colors):
        pieces = []
        other_cols = []
        for color in colors:
            for other_color in COLORS - {color}:
                piece = self.cube.find_piece(color, other_color)
                if piece is not None and piece not in pieces:
                    pieces.append(piece)
                    other_cols.append(other_color)
                    break

        self._cross_left_or_right(
            pieces[0], self.left_piece, other_cols[0], "L L", "E L Ei Li"
        )
        self._cross_left_or_right(
            pieces[1], self.right_piece, other_cols[1], "R R", "Ei R E Ri"
        )

        self.move("Z")

        self._cross_left_or_right(
            pieces[3], self.down_piece, other_cols[3], "L L", "E L Ei Li"
        )
        self._cross_left_or_right(
            pieces[2], self.up_piece, other_cols[2], "R R", "Ei R E Ri"
        )

        self.move("Zi")

    def place_corners(self, *colors):
        pieces = []
        for color in colors:
            for color_a, color_b in product(COLORS - {color}, repeat=2):
                piece = self.cube.find_piece(color, color_a, color_b)
                if piece is not None and piece not in pieces:
                    pieces.append(piece)
                    break

        self.place_frd_corner(pieces[0], self.right_piece, self.down_piece, colors[0])
        self.move("Z")
        self.place_frd_corner(pieces[1], self.up_piece, self.right_piece, colors[1])
        self.move("Z")
        self.place_frd_corner(pieces[2], self.left_piece, self.up_piece, colors[2])
        self.move("Z")
        self.place_frd_corner(pieces[3], self.down_piece, self.left_piece, colors[3])
        self.move("Z")

    def move(self, move_str):
        self.moves.extend(move_str.split())
        self.cube.sequence(move_str)

    def _cross_left_or_right(self, edge_piece, face_piece, face_color, move_1, move_2):
        # ensure piece is at z = -1
        undo_move = None
        if edge_piece.pos.z == 0:
            pos = Point(edge_piece.pos)
            pos.x = 0  # pick the UP or DOWN face
            cw, cc = cube.get_rot_from_face(pos)

            if edge_piece.pos in (cube.LEFT + cube.UP, cube.RIGHT + cube.DOWN):
                self.move(cw)
                undo_move = cc
            else:
                self.move(cc)
                undo_move = cw
        elif edge_piece.pos.z == 1:
            pos = Point(edge_piece.pos)
            pos.z = 0
            cw, cc = cube.get_rot_from_face(pos)
            self.move("{0} {0}".format(cc))
            # don't set the undo move if the piece starts out in the right position
            # (with wrong orientation) or we'll screw up the remainder of the algorithm
            if edge_piece.pos.x != face_piece.pos.x:
                undo_move = "{0} {0}".format(cw)

        assert edge_piece.pos.z == -1

        # piece is at z = -1, rotate to correct face (LEFT or RIGHT)
        count = 0
        while (edge_piece.pos.x, edge_piece.pos.y) != (
            face_piece.pos.x,
            face_piece.pos.y,
        ):
            self.move("B")
            count += 1
            if count >= self.inifinite_loop_max_iterations:
                raise Exception("Stuck in loop - unsolvable cube?\n" + str(self.cube))

        # if we moved a correctly-placed piece, restore it
        if undo_move:
            self.move(undo_move)

        # the piece is on the correct face on plane z = -1, but has two orientations
        if edge_piece.colors[0] == face_color:
            self.move(move_1)
        else:
            self.move(move_2)

    def place_frd_corner(self, corner_piece, right_piece, down_piece, front_color):
        # rotate to z = -1
        if corner_piece.pos.z == 1:
            pos = Point(corner_piece.pos)
            pos.x = pos.z = 0
            cw, cc = cube.get_rot_from_face(pos)

            # be careful not to screw up other pieces on the front face
            count = 0
            undo_move = cc
            while corner_piece.pos.z != -1:
                self.move(cw)
                count += 1

            if count > 1:
                # go the other direction because I don't know which is which.
                # we need to do only one flip (net) or we'll move other
                # correctly-placed corners out of place.
                for _ in range(count):
                    self.move(cc)

                count = 0
                while corner_piece.pos.z != -1:
                    self.move(cc)
                    count += 1
                undo_move = cw
            self.move("B")
            for _ in range(count):
                self.move(undo_move)

        # rotate piece to be directly below its destination
        while (corner_piece.pos.x, corner_piece.pos.y) != (
            right_piece.pos.x,
            down_piece.pos.y,
        ):
            self.move("B")

        # there are three possible orientations for a corner
        if corner_piece.colors[0] == front_color:
            self.move("B D Bi Di")
        elif corner_piece.colors[1] == front_color:
            self.move("Bi Ri B R")
        else:
            self.move("Ri B B R Bi Bi D Bi Di")


def main():
    r = remote(sys.argv[1], 12345)
    r.recvlines(8)

    picture = [[None] * W for _ in range(H)]

    for _ in tqdm(range(W * H)):
        r.recvline()

        cube_raw = "\n".join(r.recvlinesS(9))
        # print(cube_raw)
        cube_str = "".join(cube_raw.split())

        cube = Cube(cube_str)

        x, y = eval(r.recvline().decode()[28:-1])

        face = r.recvlinesS(3)
        # print(*face, sep="\n")
        picture[y][x] = face

        solver = Painter(cube)
        solver.paint("".join(face))

        r.sendline(" ".join(solver.moves).encode())
        r.recvline()
    r.recvline()

    for threeline in picture:
        for i in range(3):
            print("".join(line[i] for line in threeline).replace("W", " "))


if __name__ == "__main__":
    main()
